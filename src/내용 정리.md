# Chapter2. 스프링 부트에서 테스트 코드를 작성하자
- TDD와 단위 테스트는 다르다!
  - TDD는 테스트가 주도하는 개발로, 테스트 코드를 먼저 작성하는 것부터 시작한다.
  - 단위 테스트는 TDD와 달리 테스트 코드를 꼭 먼저 작성해야 하는 것이 아니고, 순수하게 테스트 코드만 작성하는 것을 이야기한다.
- 내장 WAS를 사용하는 것을 권장
  - 내장 WAS란 애플리케이션을 실행할 때 내부에서 WAS를 실행하는 것을 이야기한다.
  - 즉, 내 컴퓨터이든, ec2이든 스프링 부트로 만들어진 Jar 파일만 실행하면 된다.
  - 이렇게 되면 항상 서버에 톰캣을 따로 설치할 필요 없이 Jar 파일만 실행함으로서 톰캣이 설치되어 웹 애플리케이션 서버를 실행한다.
- @WebMvcTest
  - @WebMvcTest는 컨트롤러 계층 만을 슬라이스 테스트할 수 있도록 도와주는 어노테이션이다.
  - 이 클래스를 통해 HTTP GET,POST 등에 대한 API 테스트를 할 수 있다.
  - 외부 연동과 관련된 부분뿐만 아닌, JPA 기능까지 한번에 테스트 할 때에는 @SpringBootTest와 TestRestTemplate을 사용해라!
- 요청 매핑
  - @PathVariable
    - Get 방식의 URL 속의 쿼리 파라미터로 매핑
  - @RequestParam
    - Post 방식의 메세지 바디 속 쿼리 파라미터로 매핑
- jsonPath
  - JSON 응답값을 필드별로 검증할 수 있는 메소드이다.
  - $를 기준으로 필드명을 명시한다.
- 깃허브에 contribute 안되는 이유
  - git config user.email 시 내 깃허브 계정인지 확인

# Chapter3. 스프링 부트에서 JPA로 데이터베이스 다뤄보자
- JPA를 사용하자
  - 개발자는 객체지향적인 개발을 하고, JPA가 이를 관계형 데이터베이스에 맞게 SQL을 대신 생성해서 실행
  - 패러다임 불일치 해결
  - 의존성 추가
    - implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
- Hibernate를 직접 쓰기 보다는 Spring Data JPA 를 사용하자
  - 구현체 교체의 용이성
  - 저장소 교체의 용이성
- 관계형 데이터베이스를 사용할 때 runtimeOnly 의존성을 추가해주면 된다.
  - mySQL 사용 시
    - runtimeOnly 'com.mysql:mysql-connector-j'
  - H2 사용시
    - runtimeOnly 'com.h2database:h2'
- Entity에는 절대 setter를 만들지 말자!
  - 값 변경이 필요한 경우에는 해당 이벤트에 맞는 public 메소드 호출
    - 주문 취소, 주문 변경 등
  - 기본적인 정보를 가지고 DB에 삽입해야 하는 경우 생성자 또는 @Builder를 통해 채워준다.
    - 빌더를 사용하면 어느 필드에 어떤 값을 채워야하는지 정확히 알 수 있다.
    - @NoArgsConstructor 롬복을 통해 기본 생성자를 막는다.
- JPA에서는 Repository를 인터페이스로 생성하자.
  - JpaRepository<Posts,Long>를 상속하면 기본적인 CRUD 메소드가 자동으로 생성된다.
  - @Repository를 추가할 필요도 없다.
- postsRepository.save
  - id 값이 있다면 update가(변경감지), 없다면 insert 쿼리가 실행된다.
- mysql에서는 접근이 되는데 datagrip에서는 접근이 안될 때
  - 작업관리자에서 wamp stack으로 실행되는 mysql.exe 작업 종료하기!
- table이 자동 create 안될 때
  - application.yml 파일의 jpa 탭 설정이 잘 되어있는지 확인하기!
- Service는 트랜잭션, 도메인 간 순서 보장의 역할만 한다.
  - 비즈니스 로직을 꼭 처리해야하는 것은 아니다.
  - 엔티티 각자 본인의 취소 이벤트를 처리하고, 서비스는 해당 이벤트를 호출하며 도메인 간 순서만 보장
  - 생성자 주입 시, @Autowired 애노테이션를 하지 않아도 의존 관계 주입이 진행된다!
- API를 만들기 위한 총 3개의 클래스
  - Request 데이터를 받은 DTO
    - Entity를 Request/Response 클래스로 사용해서는 안된다!
  - API 요청을 받은 Controller
  - 트랜잭션, 도메인 기능 간의 순서를 보장하는 Service
- update 문은 별도의 메서드가 아닌 변경 감지를 이용한다!
  - 따라서 Posts 엔티티 클래스에 객체 필드를 수정하는 update 메서드를 만들고, 이를 Service에서 사용하면 된다.
- 보통 Entity에는 해당 데이터의 생성 시간과 수정 시간을 포함한다.
  - JPA Auditing 사용
- Repository는 CRUD 테스트 정도만
- Service는 메서드 단위로 테스트